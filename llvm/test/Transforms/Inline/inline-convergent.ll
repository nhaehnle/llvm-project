; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -inline -S %s | FileCheck %s
; RUN: opt -passes='cgscc(inline)' -S %s | FileCheck %s

define void @nonconvergent_callee() alwaysinline {
; CHECK-LABEL: @nonconvergent_callee(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOKEN:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @f(i32 0) [ "convergencectrl"(token [[TOKEN]]) ]
; CHECK-NEXT:    ret void
;
entry:
  %token = call token @llvm.experimental.convergence.anchor()
  call void @f(i32 0) [ "convergencectrl"(token %token) ]
  ret void
}

define void @convergent_callee(i32 %v) convergent alwaysinline {
; CHECK-LABEL: @convergent_callee(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOKEN:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    call void @f(i32 [[V:%.*]]) [ "convergencectrl"(token [[TOKEN]]) ]
; CHECK-NEXT:    ret void
;
entry:
  %token = call token @llvm.experimental.convergence.entry()
  call void @f(i32 %v) [ "convergencectrl"(token %token) ]
  ret void
}

define void @test_nonconvergent() {
; CHECK-LABEL: @test_nonconvergent(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOKEN_I:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @f(i32 0) [ "convergencectrl"(token [[TOKEN_I]]) ]
; CHECK-NEXT:    ret void
;
entry:
  call void @nonconvergent_callee()
  ret void
}

define void @test_convergent_basic() {
; CHECK-LABEL: @test_convergent_basic(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOKEN:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 undef, label [[THEN:%.*]], label [[END:%.*]]
; CHECK:       then:
; CHECK-NEXT:    call void @f(i32 0) [ "convergencectrl"(token [[TOKEN]]) ]
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %token = call token @llvm.experimental.convergence.anchor()
  br i1 undef, label %then, label %end

then:
  call void @convergent_callee(i32 0) [ "convergencectrl"(token %token) ]
  br label %end

end:
  ret void
}

define void @test_convergent_multiple() convergent {
; CHECK-LABEL: @test_convergent_multiple(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOKEN:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    call void @f(i32 0) [ "convergencectrl"(token [[TOKEN]]) ]
; CHECK-NEXT:    call void @f(i32 1) [ "convergencectrl"(token [[TOKEN]]) ]
; CHECK-NEXT:    call void @f(i32 2) [ "convergencectrl"(token [[TOKEN]]) ]
; CHECK-NEXT:    ret void
;
entry:
  %token = call token @llvm.experimental.convergence.entry()
  call void @convergent_callee(i32 0) [ "convergencectrl"(token %token) ]
  call void @convergent_callee(i32 1) [ "convergencectrl"(token %token) ]
  call void @convergent_callee(i32 2) [ "convergencectrl"(token %token) ]
  ret void
}

define void @test_convergent_loop() {
; CHECK-LABEL: @test_convergent_loop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOKEN:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 undef, label [[HDR:%.*]], label [[END:%.*]]
; CHECK:       hdr:
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOKEN]]) ]
; CHECK-NEXT:    call void @f(i32 0) [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    br i1 undef, label [[HDR]], label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %token = call token @llvm.experimental.convergence.anchor()
  br i1 undef, label %hdr, label %end

hdr:
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %token) ]
  call void @convergent_callee(i32 0) [ "convergencectrl"(token %tok.loop) ]
  br i1 undef, label %hdr, label %end

end:
  ret void
}

declare void @f(i32) convergent

declare token @llvm.experimental.convergence.entry()
declare token @llvm.experimental.convergence.anchor()
declare token @llvm.experimental.convergence.loop()
