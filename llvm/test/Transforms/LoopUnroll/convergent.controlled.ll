; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -loop-unroll -unroll-runtime -unroll-allow-partial -S | FileCheck %s

declare void @f() convergent
declare void @g()

; Although this loop contains a convergent instruction, it should be
; fully unrolled.
define i32 @full_unroll() {
; CHECK-LABEL: @full_unroll(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[L3:%.*]]
; CHECK:       l3:
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    ret i32 0
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br label %l3

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, 3
  br i1 %exitcond, label %exit, label %l3

exit:
  ret i32 0
}

; This loop contains a convergent instruction, but it should be partially
; unrolled.  The unroll count is the largest power of 2 that divides the
; multiple -- 4, in this case.
define i32 @runtime_unroll(i32 %n) {
; CHECK-LABEL: @runtime_unroll(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    [[LOOP_CTL:%.*]] = mul nsw i32 [[N:%.*]], 12
; CHECK-NEXT:    br label [[L3:%.*]]
; CHECK:       l3:
; CHECK-NEXT:    [[X_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_3:%.*]], [[L3]] ]
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[X_0]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_1:%.*]] = add nuw nsw i32 [[INC]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_2:%.*]] = add nuw nsw i32 [[INC_1]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_3]] = add nsw i32 [[INC_2]], 1
; CHECK-NEXT:    [[EXITCOND_3:%.*]] = icmp eq i32 [[INC_3]], [[LOOP_CTL]]
; CHECK-NEXT:    br i1 [[EXITCOND_3]], label [[EXIT:%.*]], label [[L3]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  %loop_ctl = mul nsw i32 %n, 12
  br label %l3

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, %loop_ctl
  br i1 %exitcond, label %exit, label %l3

exit:
  ret i32 0
}

; This loop contains a convergent instruction, so its partial unroll
; count must divide its trip multiple.  This overrides its unroll
; pragma -- we unroll exactly 8 times, even though 16 is requested.
define i32 @pragma_unroll(i32 %n) {
; CHECK-LABEL: @pragma_unroll(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    [[LOOP_CTL:%.*]] = mul nsw i32 [[N:%.*]], 24
; CHECK-NEXT:    br label [[L3:%.*]], !llvm.loop !0
; CHECK:       l3:
; CHECK-NEXT:    [[X_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_7:%.*]], [[L3]] ]
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[X_0]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_1:%.*]] = add nuw nsw i32 [[INC]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_2:%.*]] = add nuw nsw i32 [[INC_1]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_3:%.*]] = add nuw nsw i32 [[INC_2]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_4:%.*]] = add nuw nsw i32 [[INC_3]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_5:%.*]] = add nuw nsw i32 [[INC_4]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_6:%.*]] = add nuw nsw i32 [[INC_5]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_7]] = add nsw i32 [[INC_6]], 1
; CHECK-NEXT:    [[EXITCOND_7:%.*]] = icmp eq i32 [[INC_7]], [[LOOP_CTL]]
; CHECK-NEXT:    br i1 [[EXITCOND_7]], label [[EXIT:%.*]], label [[L3]], !llvm.loop !2
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  %loop_ctl = mul nsw i32 %n, 24
  br label %l3, !llvm.loop !0

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, %loop_ctl
  br i1 %exitcond, label %exit, label %l3, !llvm.loop !0

exit:
  ret i32 0
}

; This loop contains a convergent instruction. Since the pragma loop unroll
; count 2 divides trip count 4. The loop unroll should respect the pragma.
define void @pragma_unroll_divisible_trip_count() {
; CHECK-LABEL: @pragma_unroll_divisible_trip_count(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[L3:%.*]], !llvm.loop !4
; CHECK:       l3:
; CHECK-NEXT:    [[X_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_1:%.*]], [[L3]] ]
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[X_0]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_1]] = add nuw nsw i32 [[INC]], 1
; CHECK-NEXT:    [[EXITCOND_1:%.*]] = icmp eq i32 [[INC_1]], 4
; CHECK-NEXT:    br i1 [[EXITCOND_1]], label [[EXIT:%.*]], label [[L3]], !llvm.loop !6
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br label %l3, !llvm.loop !1

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, 4
  br i1 %exitcond, label %exit, label %l3, !llvm.loop !1

exit:
  ret void
}

; This loop contains a convergent instruction. Since the pragma loop unroll
; count 2 divides trip multiple 2. The loop unroll should respect the pragma.
define i32 @pragma_unroll_divisible_trip_multiple(i32 %n) {
; CHECK-LABEL: @pragma_unroll_divisible_trip_multiple(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    [[LOOP_CTL:%.*]] = mul nsw i32 [[N:%.*]], 2
; CHECK-NEXT:    br label [[L3:%.*]], !llvm.loop !4
; CHECK:       l3:
; CHECK-NEXT:    [[X_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_1:%.*]], [[L3]] ]
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[X_0]], 1
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC_1]] = add nsw i32 [[INC]], 1
; CHECK-NEXT:    [[EXITCOND_1:%.*]] = icmp eq i32 [[INC_1]], [[LOOP_CTL]]
; CHECK-NEXT:    br i1 [[EXITCOND_1]], label [[EXIT:%.*]], label [[L3]], !llvm.loop !7
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  %loop_ctl = mul nsw i32 %n, 2
  br label %l3, !llvm.loop !1

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, %loop_ctl
  br i1 %exitcond, label %exit, label %l3, !llvm.loop !1

exit:
  ret i32 0
}

; This loop contains a convergent instruction. Since the pragma loop unroll
; count 2 is unknown to divide runtime trip count, the loop is not unrolled
; since remainder is forbidden for unrolling convergent loop.
define i32 @pragma_unroll_indivisible_runtime_trip_count(i32 %n) {
; CHECK-LABEL: @pragma_unroll_indivisible_runtime_trip_count(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[L3:%.*]], !llvm.loop !4
; CHECK:       l3:
; CHECK-NEXT:    [[X_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[L3]] ]
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    [[INC]] = add nsw i32 [[X_0]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[EXIT:%.*]], label [[L3]], !llvm.loop !4
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br label %l3, !llvm.loop !1

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  call void @f() [ "convergencectrl"(token %anchor) ]
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, %n
  br i1 %exitcond, label %exit, label %l3, !llvm.loop !1

exit:
  ret i32 0
}

; This loop contains a convergent instruction. Since the pragma loop unroll
; count 2 does not divide trip count 5, the loop is not unrolled by 2
; since remainder is forbidden for unrolling convergent loop. Instead, the
; loop gets fully unrolled.
define i32 @pragma_unroll_indivisible_trip_count() {
; CHECK-LABEL: @pragma_unroll_indivisible_trip_count(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[L3:%.*]], !llvm.loop !4
; CHECK:       l3:
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    ret i32 0
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br label %l3, !llvm.loop !1

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, 5
  br i1 %exitcond, label %exit, label %l3, !llvm.loop !1

exit:
  ret i32 0
}

; This loop contains a convergent instruction that is anchored inside the loop
; itself. It is unrolled by 2 with remainder, as requested by the loop metadata.
define i32 @pragma_unroll_with_remainder(i32 %n) {
; CHECK-LABEL: @pragma_unroll_with_remainder(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N:%.*]], -1
; CHECK-NEXT:    [[XTRAITER:%.*]] = and i32 [[N]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i32 [[TMP0]], 1
; CHECK-NEXT:    br i1 [[TMP1]], label [[EXIT_UNR_LCSSA:%.*]], label [[ENTRY_NEW:%.*]]
; CHECK:       entry.new:
; CHECK-NEXT:    [[UNROLL_ITER:%.*]] = sub i32 [[N]], [[XTRAITER]]
; CHECK-NEXT:    br label [[L3:%.*]], !llvm.loop !4
; CHECK:       l3:
; CHECK-NEXT:    [[X_0:%.*]] = phi i32 [ 0, [[ENTRY_NEW]] ], [ [[INC_1:%.*]], [[L3]] ]
; CHECK-NEXT:    [[NITER:%.*]] = phi i32 [ [[UNROLL_ITER]], [[ENTRY_NEW]] ], [ [[NITER_NSUB_1:%.*]], [[L3]] ]
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[X_0]], 1
; CHECK-NEXT:    [[NITER_NSUB:%.*]] = sub i32 [[NITER]], 1
; CHECK-NEXT:    [[TOK_LOOP_1:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP_1]]) ]
; CHECK-NEXT:    [[INC_1]] = add nsw i32 [[INC]], 1
; CHECK-NEXT:    [[NITER_NSUB_1]] = sub i32 [[NITER_NSUB]], 1
; CHECK-NEXT:    [[NITER_NCMP_1:%.*]] = icmp eq i32 [[NITER_NSUB_1]], 0
; CHECK-NEXT:    br i1 [[NITER_NCMP_1]], label [[EXIT_UNR_LCSSA_LOOPEXIT:%.*]], label [[L3]], !llvm.loop !8
; CHECK:       exit.unr-lcssa.loopexit:
; CHECK-NEXT:    [[X_0_UNR_PH:%.*]] = phi i32 [ [[INC_1]], [[L3]] ]
; CHECK-NEXT:    br label [[EXIT_UNR_LCSSA]]
; CHECK:       exit.unr-lcssa:
; CHECK-NEXT:    [[X_0_UNR:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[X_0_UNR_PH]], [[EXIT_UNR_LCSSA_LOOPEXIT]] ]
; CHECK-NEXT:    [[LCMP_MOD:%.*]] = icmp ne i32 [[XTRAITER]], 0
; CHECK-NEXT:    br i1 [[LCMP_MOD]], label [[L3_EPIL_PREHEADER:%.*]], label [[EXIT:%.*]]
; CHECK:       l3.epil.preheader:
; CHECK-NEXT:    br label [[L3_EPIL:%.*]]
; CHECK:       l3.epil:
; CHECK-NEXT:    [[X_0_EPIL:%.*]] = phi i32 [ [[X_0_UNR]], [[L3_EPIL_PREHEADER]] ]
; CHECK-NEXT:    [[TOK_LOOP_EPIL:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP_EPIL]]) ]
; CHECK-NEXT:    [[INC_EPIL:%.*]] = add nsw i32 [[X_0_EPIL]], 1
; CHECK-NEXT:    [[EXITCOND_EPIL:%.*]] = icmp eq i32 [[INC_EPIL]], [[N]]
; CHECK-NEXT:    br label [[EXIT_EPILOG_LCSSA:%.*]]
; CHECK:       exit.epilog-lcssa:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  br label %l3, !llvm.loop !1

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.anchor()
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, %n
  br i1 %exitcond, label %exit, label %l3, !llvm.loop !1

exit:
  ret i32 0
}

; Don't unroll a loop that is extended by convergence controls.
;
; We could theoretically duplicate the extension part, but this is not
; implemented.
define i32 @extended_loop(i32 %n) {
; CHECK-LABEL: @extended_loop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[L3:%.*]], !llvm.loop !4
; CHECK:       l3:
; CHECK-NEXT:    [[X_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[L3]] ]
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    [[INC]] = add nsw i32 [[X_0]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[EXIT:%.*]], label [[L3]], !llvm.loop !4
; CHECK:       exit:
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    ret i32 0
;
entry:
  br label %l3, !llvm.loop !1

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %l3 ]
  %tok.loop = call token @llvm.experimental.convergence.anchor()
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, %n
  br i1 %exitcond, label %exit, label %l3, !llvm.loop !1

exit:
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  ret i32 0
}

; The heart of this loop does not dominate all latches. It cannot be unrolled.
define i32 @unusual_heart(i32 %v) {
; CHECK-LABEL: @unusual_heart(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[L3:%.*]]
; CHECK:       l3:
; CHECK-NEXT:    [[X_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LATCH:%.*]] ]
; CHECK-NEXT:    [[BRANCHCOND:%.*]] = icmp eq i32 [[X_0]], [[V:%.*]]
; CHECK-NEXT:    br i1 [[BRANCHCOND]], label [[THEN:%.*]], label [[LATCH]]
; CHECK:       then:
; CHECK-NEXT:    [[TOK_LOOP:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    call void @f() [ "convergencectrl"(token [[TOK_LOOP]]) ]
; CHECK-NEXT:    br label [[LATCH]]
; CHECK:       latch:
; CHECK-NEXT:    call void @g()
; CHECK-NEXT:    [[INC]] = add nsw i32 [[X_0]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], 3
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[EXIT:%.*]], label [[L3]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br label %l3

l3:
  %x.0 = phi i32 [ 0, %entry ], [ %inc, %latch ]
  %branchcond = icmp eq i32 %x.0, %v
  br i1 %branchcond, label %then, label %latch

then:
  %tok.loop = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  call void @f() [ "convergencectrl"(token %tok.loop) ]
  br label %latch

latch:
  call void @g()
  %inc = add nsw i32 %x.0, 1
  %exitcond = icmp eq i32 %inc, 3
  br i1 %exitcond, label %exit, label %l3

exit:
  ret i32 0
}

declare token @llvm.experimental.convergence.anchor()
declare token @llvm.experimental.convergence.loop()

!0 = !{!0, !{!"llvm.loop.unroll.count", i32 16}}
!1 = !{!1, !{!"llvm.loop.unroll.count", i32 2}}
