; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -S -convergence-control-heuristic | FileCheck %s -check-prefix=CHECK

define void @empty() {
; CHECK-LABEL: @empty(
; CHECK-NEXT:    ret void
;
  ret void
}

define void @simple_convergent() convergent {
; CHECK-LABEL: @simple_convergent(
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP1]]) ]
; CHECK-NEXT:    ret void
;
  call void @convergent.op(i32 0)
  ret void
}

define void @simple_nonconvergent() {
; CHECK-LABEL: @simple_nonconvergent(
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP1]]) ]
; CHECK-NEXT:    ret void
;
  call void @convergent.op(i32 0)
  ret void
}

define void @preserve_bundles_and_metadata() {
; CHECK-LABEL: @preserve_bundles_and_metadata(
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.experimental.convergence.anchor(), !dbg !1
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "unknown-bundle"(i32 0), "convergencectrl"(token [[TMP1]]) ], !dbg !1, !unknown !5
; CHECK-NEXT:    ret void
;
  call void @convergent.op(i32 0) [ "unknown-bundle"(i32 0) ], !dbg !2, !unknown !0
  ret void
}

define void @acyclic() convergent {
; CHECK-LABEL: @acyclic(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    br i1 undef, label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    br label [[B]]
; CHECK:       B:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    ret void
;
entry:
  br i1 undef, label %A, label %B

A:
  call void @convergent.op(i32 0)
  br label %B

B:
  call void @convergent.op(i32 0)
  ret void
}

;
;      |
;      A]
;      |
;   /->B
;   |  |\
;   |  | C]
;   |  |/
;   ^-<D
;      |
;      E
;
define void @natural_loops() convergent {
; CHECK-LABEL: @natural_loops(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    br label [[A:%.*]]
; CHECK:       A:
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP1]]) ]
; CHECK-NEXT:    br i1 undef, label [[A]], label [[B:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TMP2:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP2]]) ]
; CHECK-NEXT:    br i1 undef, label [[C:%.*]], label [[D:%.*]]
; CHECK:       C:
; CHECK-NEXT:    [[TMP3:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TMP2]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP3]]) ]
; CHECK-NEXT:    br i1 undef, label [[C]], label [[D]]
; CHECK:       D:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP2]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[E:%.*]]
; CHECK:       E:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    ret void
;
entry:
  br label %A

A:
  call void @convergent.op(i32 0)
  br i1 undef, label %A, label %B

B:
  call void @convergent.op(i32 0)
  br i1 undef, label %C, label %D

C:
  call void @convergent.op(i32 0)
  br i1 undef, label %C, label %D

D:
  call void @convergent.op(i32 0)
  br i1 undef, label %B, label %E

E:
  call void @convergent.op(i32 0)
  ret void
}

;
;   |   |
;   A<->B
;   ^   ^
;   |   |
;   v   v
;   C   D
;    \ /
;     E
;
define void @irreducible() convergent {
; CHECK-LABEL: @irreducible(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    br i1 undef, label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP1]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[C:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TMP2:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP2]]) ]
; CHECK-NEXT:    br i1 undef, label [[A]], label [[D:%.*]]
; CHECK:       C:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP1]]) ]
; CHECK-NEXT:    br i1 undef, label [[A]], label [[E:%.*]]
; CHECK:       D:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP2]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[E]]
; CHECK:       E:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    ret void
;
entry:
  br i1 undef, label %A, label %B

A:
  call void @convergent.op(i32 0)
  br i1 undef, label %B, label %C

B:
  call void @convergent.op(i32 0)
  br i1 undef, label %A, label %D

C:
  call void @convergent.op(i32 0)
  br i1 undef, label %A, label %E

D:
  call void @convergent.op(i32 0)
  br i1 undef, label %B, label %E

E:
  call void @convergent.op(i32 0)
  ret void
}

!llvm.module.flags = !{!1}

!0 = !{}
!1 = !{i32 2, !"Debug Info Version", i32 3}
!2 = !DILocation(scope: !3)
!3 = distinct !DISubprogram(name: "main", unit: !4)
!4 = distinct !DICompileUnit(language: DW_LANG_C99, file: !5)
!5 = !DIFile(filename: "foo", directory: "bar")

declare void @convergent.op(i32) convergent
