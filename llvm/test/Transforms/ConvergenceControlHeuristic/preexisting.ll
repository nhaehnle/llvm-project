; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -S -convergence-control-heuristic | FileCheck %s -check-prefix=CHECK

define void @simple() convergent {
; CHECK-LABEL: @simple(
; CHECK-NEXT:  A:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 1) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    ret void
;
A:
  %a = call token @llvm.experimental.convergence.entry()
  call void @convergent.op(i32 0) [ "convergencectrl"(token %a) ]
  call void @convergent.op(i32 1)
  ret void
}

define void @simple2() {
; CHECK-LABEL: @simple2(
; CHECK-NEXT:  A:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 1) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    ret void
;
A:
  %a = call token @llvm.experimental.convergence.anchor()
  call void @convergent.op(i32 0)
  call void @convergent.op(i32 1) [ "convergencectrl"(token %a) ]
  ret void
}

define void @natural_loop() {
; CHECK-LABEL: @natural_loop(
; CHECK-NEXT:  A:
; CHECK-NEXT:    [[TOK_A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[B:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TOK_B:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_B]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[C:%.*]]
; CHECK:       C:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    ret void
;
A:
  %tok.a = call token @llvm.experimental.convergence.anchor()
  br label %B

B:
  %tok.b = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %tok.a) ]
  call void @convergent.op(i32 0)
  br i1 undef, label %B, label %C

C:
  call void @convergent.op(i32 0)
  ret void
}

define void @natural_loop2() {
; CHECK-LABEL: @natural_loop2(
; CHECK-NEXT:  A:
; CHECK-NEXT:    [[TOK_A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[B:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TOK_B:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[C:%.*]]
; CHECK:       C:
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    br i1 undef, label [[C]], label [[D:%.*]]
; CHECK:       D:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    ret void
;
A:
  %tok.a = call token @llvm.experimental.convergence.anchor()
  br label %B

B:
  %tok.b = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %tok.a) ]
  br i1 undef, label %B, label %C

C:
  call void @convergent.op(i32 0)
  br i1 undef, label %C, label %D

D:
  call void @convergent.op(i32 0)
  ret void
}

define void @natural_loop_extended1() {
; CHECK-LABEL: @natural_loop_extended1(
; CHECK-NEXT:  A:
; CHECK-NEXT:    [[TOK_A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[B:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TOK_B:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[C:%.*]]
; CHECK:       C:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_B]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 1) [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    ret void
;
A:
  %tok.a = call token @llvm.experimental.convergence.anchor()
  br label %B

B:
  %tok.b = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %tok.a) ]
  br i1 undef, label %B, label %C

C:
  call void @convergent.op(i32 0) [ "convergencectrl"(token %tok.b) ]
  call void @convergent.op(i32 1)
  ret void
}

define void @natural_loop_extended2() {
; CHECK-LABEL: @natural_loop_extended2(
; CHECK-NEXT:  A:
; CHECK-NEXT:    [[TOK_A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[B:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TOK_B:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[C:%.*]]
; CHECK:       C:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_B]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 1) [ "convergencectrl"(token [[TOK_B]]) ]
; CHECK-NEXT:    ret void
;
A:
  %tok.a = call token @llvm.experimental.convergence.anchor()
  br label %B

B:
  %tok.b = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %tok.a) ]
  br i1 undef, label %B, label %C

C:
  call void @convergent.op(i32 0)
  call void @convergent.op(i32 1) [ "convergencectrl"(token %tok.b) ]
  ret void
}

;
;      A
;      |
;      B]
;      |
;      C]
;      |
;      D
;      |\
;      | E
;      |/
;      F
;
define void @natural_loop_extended3() {
; CHECK-LABEL: @natural_loop_extended3(
; CHECK-NEXT:  A:
; CHECK-NEXT:    [[TOK_A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[B:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TOK_B:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[C:%.*]]
; CHECK:       C:
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOK_B]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    br i1 undef, label [[C]], label [[D:%.*]]
; CHECK:       D:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_B]]) ]
; CHECK-NEXT:    br i1 undef, label [[E:%.*]], label [[F:%.*]]
; CHECK:       E:
; CHECK-NEXT:    call void @convergent.op(i32 1) [ "convergencectrl"(token [[TOK_B]]) ]
; CHECK-NEXT:    br label [[F]]
; CHECK:       F:
; CHECK-NEXT:    ret void
;
A:
  %tok.a = call token @llvm.experimental.convergence.anchor()
  br label %B

B:
  %tok.b = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %tok.a) ]
  br i1 undef, label %B, label %C

C:
  call void @convergent.op(i32 0)
  br i1 undef, label %C, label %D

D:
  call void @convergent.op(i32 0)
  br i1 undef, label %E, label %F

E:
  call void @convergent.op(i32 1) [ "convergencectrl"(token %tok.b) ]
  br label %F

F:
  ret void
}

define void @unusual_heart() {
; CHECK-LABEL: @unusual_heart(
; CHECK-NEXT:  A:
; CHECK-NEXT:    [[TOK_A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label [[B:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    br i1 undef, label [[C:%.*]], label [[D:%.*]]
; CHECK:       C:
; CHECK-NEXT:    [[TOK_C:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_C]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[D]]
; CHECK:       D:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[E:%.*]]
; CHECK:       E:
; CHECK-NEXT:    ret void
;
A:
  %tok.a = call token @llvm.experimental.convergence.anchor()
  br label %B

B:
  call void @convergent.op(i32 0)
  br i1 undef, label %C, label %D

C:
  %tok.c = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %tok.a) ]
  call void @convergent.op(i32 0)
  br i1 undef, label %B, label %D

D:
  call void @convergent.op(i32 0)
  br i1 undef, label %B, label %E

E:
  ret void
}

;
;   |   |
;   A<->B
;   ^   ^
;   |   |
;   v   v
;   C   D
;    \ /
;     E
;
define void @irreducible1() {
; CHECK-LABEL: @irreducible1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 undef, label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    [[TOK_A:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[C:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 undef, label [[A]], label [[D:%.*]]
; CHECK:       C:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_A]]) ]
; CHECK-NEXT:    br i1 undef, label [[A]], label [[E:%.*]]
; CHECK:       D:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[E]]
; CHECK:       E:
; CHECK-NEXT:    ret void
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br i1 undef, label %A, label %B

A:
  %tok.a = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  br i1 undef, label %B, label %C

B:
  br i1 undef, label %A, label %D

C:
  call void @convergent.op(i32 0)
  br i1 undef, label %A, label %E

D:
  call void @convergent.op(i32 0)
  br i1 undef, label %B, label %E

E:
  ret void
}

; Same CFG, different initial loop heart
define void @irreducible2() {
; CHECK-LABEL: @irreducible2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 undef, label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 undef, label [[B]], label [[C:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TOK_B:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    br i1 undef, label [[A]], label [[D:%.*]]
; CHECK:       C:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TMP0]]) ]
; CHECK-NEXT:    br i1 undef, label [[A]], label [[E:%.*]]
; CHECK:       D:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[TOK_B]]) ]
; CHECK-NEXT:    br i1 undef, label [[B]], label [[E]]
; CHECK:       E:
; CHECK-NEXT:    ret void
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br i1 undef, label %A, label %B

A:
  br i1 undef, label %B, label %C

B:
  %tok.b = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  br i1 undef, label %A, label %D

C:
  call void @convergent.op(i32 0)
  br i1 undef, label %A, label %E

D:
  call void @convergent.op(i32 0)
  br i1 undef, label %B, label %E

E:
  ret void
}

declare void @convergent.op(i32) convergent

declare token @llvm.experimental.convergence.entry()
declare token @llvm.experimental.convergence.anchor()
declare token @llvm.experimental.convergence.loop()
